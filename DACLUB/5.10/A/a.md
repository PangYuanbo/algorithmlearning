## A_MovieFestival:
动态规划的算法不能解决这个问题，因为动态规划的算法需要知道所有的数据，而这个问题的数据是会超时（时间复杂的为O(n^2)，所以只能用贪心算法来解决这个问题。
贪心算法的思路是：先将所有的电影按照结束时间排序，然后从第一个电影开始，选择结束时间最早的电影，然后再选择结束时间最早的电影，直到所有的电影都被选择。
对于某些问题，贪心算法可能不会产生最优解，因为贪心策略通常局限于局部最优解，而不总是能找到全局最优解。然而，对于**活动选择问题**，贪心算法是有保证的最优解法。

### 活动选择问题的贪心选择性质

在活动选择问题中，目标是选择最大数量的互不重叠的活动。这个问题的特殊之处在于，它可以通过贪心算法达到最优解。根据算法的设计，每次都选择结束时间最早的尚未开始的活动，可以确保为后续活动留出尽可能多的时间，从而最大化能参与的活动数量。

### 为什么贪心算法在这里是最优的？

这是因为每次选择都是基于如何最快地释放资源（在此场景中是时间），从而为更多的活动腾出空间。这种策略能够确保你在每个可能的时间段都进行了最多的活动选择，而不会错过任何可能的机会。

### 反例的可能性

对于特定的问题，如背包问题或图的顶点覆盖问题等，贪心算法可能仅能得到近似解或局部最优解，而不是全局最优解。这些问题的结构和约束条件使得简单的局部最优选择不能保证全局最优。

例如，在分数背包问题中，可以通过贪心算法达到最优解，即根据单位重量价值进行选择。然而，在0/1背包问题中，每个物品只能完整选取或不取，此时贪心策略就可能无法得到最优解，因为最优解可能需要综合多个物品的选择效果。

### 结论

所以，对于活动选择问题，使用贪心算法来按结束时间排序并选择活动是最优的策略，并不存在反例。但对于其他复杂的问题，贪心算法的适用性和效果则会有所不同，可能需要更复杂的策略如动态规划或回溯算法来保证得到最优解。

### 代码实现
1. Dp:
   // 使用 std::sort 来排序时间
   sort(a.begin(), a.end(), cmp);

   // 初始化第一个电影的计数为 1
   a[0].count = 1;

   // 计算最大的电影观看序列
   for (int i = 1; i < n; i++) {
   int max_count = 0;
   for (int j = 0; j < i; j++) {
   if (a[i].start >= a[j].end && a[j].count > max_count) {
   max_count = a[j].count;
   }
   }
   a[i].count = max_count + 1;
   }
2. 贪心：

   // 根据结束时间排序
   std::sort(a.begin(), a.end(), cmp);

   // 选择不重叠的时间段
   int count = 0;
   int last_end_time = -1;
   for (const auto& movie : a) {
   if (movie.start >= last_end_time) {
   last_end_time = movie.end;
   count++;
   }
   }